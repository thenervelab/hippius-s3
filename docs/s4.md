# Hippius S4: Atomic Append Extensions

Status: Experimental (opt-in via metadata)

Overview

Hippius S4 enables atomic, O(delta) appends to an existing object while keeping standard S3 clients unchanged. Writers use PutObject with x-amz-meta-\* hints; readers use normal GET/HEAD.

Writer API (PutObject with metadata)

- x-amz-meta-append: true (required)
- x-amz-meta-append-if-version: <int> (required CAS)
- x-amz-meta-append-id: <uuid> (optional idempotency for retries)

Server behavior

- Treats body as append delta; publishes only the new chunk to IPFS.
- Atomically appends a new part to the object manifest and updates size and composite ETag (multipart-style) in a single transaction.
- Validates `append-if-version` against the current `append_version`; on mismatch, returns 412 PreconditionFailed.
- On success, increments `append_version`.
- Successful responses include `x-amz-meta-append-version: <int>` so clients can chain appends without an extra HEAD.
- HEAD/GET reflect new content, new ETag, and the updated version immediately.

Reader API (unchanged)

- GET streams the entire object from its parts (supports Range across chunks).
- HEAD returns Content-Length, Content-Type, ETag, user metadata, and `x-amz-meta-append-version: <int>` to support version-based CAS from S3 clients.

Concurrency and atomicity

- Per-object serialization using row locks (SELECT ... FOR UPDATE).
- Version-based CAS provides linearizable append visibility. Readers see old or new, never partial.
- Optional append-id enables idempotent retries for a fixed window (server caches the successful result).

ETag semantics

- ETag is opaque; we use multipart-style ETag (MD5 over concatenated per-part MD5s with `-N` suffix). Do not use ETag for CAS.

Error codes

- 412 PreconditionFailed (XML S3 error) when `append-if-version` mismatches current version.
- 400 InvalidRequest when `append-if-version` is missing or malformed.
- 503 ServiceUnavailable when temporarily not appendable.

Examples

AWS CLI

```bash
# Fetch current append version for CAS
VER=$(aws s3api head-object \
  --bucket my-bucket \
  --key path/to/file.log \
  --endpoint-url http://localhost:8000 \
  --query 'ResponseMetadata.HTTPHeaders.x-amz-meta-append-version' --output text)

# Append new bytes from delta.bin
aws s3api put-object \
  --bucket my-bucket \
  --key path/to/file.log \
  --body delta.bin \
  --metadata append=true,append-if-version=$VER,append-id=$(uuidgen) \
  --content-type application/octet-stream \
  --endpoint-url http://localhost:8000
```

Python (boto3)

```python
import uuid
import boto3
from botocore.config import Config

s3 = boto3.client(
    "s3",
    endpoint_url="http://localhost:8000",
    aws_access_key_id="base64-encoded-seed",
    aws_secret_access_key="seed-phrase",
    region_name="decentralized",
    config=Config(signature_version="s3v4"),
)

bucket = "my-bucket"
key = "path/to/file.log"

head = s3.head_object(Bucket=bucket, Key=key)
append_version = head["ResponseMetadata"]["HTTPHeaders"].get("x-amz-meta-append-version", "0")

with open("delta.bin", "rb") as f:
    s3.put_object(
        Bucket=bucket,
        Key=key,
        Body=f,
        ContentType="application/octet-stream",
        Metadata={
            "append": "true",
            "append-if-version": append_version,
            "append-id": str(uuid.uuid4()),
        },
    )
```

Python (boto3) â€” no-HEAD fast path

```python
import uuid
import boto3
from botocore.config import Config

s3 = boto3.client(
    "s3",
    endpoint_url="http://localhost:8000",
    region_name="decentralized",
    config=Config(signature_version="s3v4"),
)

bucket = "my-bucket"
key = "path/to/file.log"

# Initial PUT (base object)
put0 = s3.put_object(Bucket=bucket, Key=key, Body=b"base-bytes")
version = put0["ResponseMetadata"]["HTTPHeaders"].get("x-amz-meta-append-version", "0")

def append(delta: bytes, ver: str) -> str:
    try:
        resp = s3.put_object(
            Bucket=bucket,
            Key=key,
            Body=delta,
            ContentType="application/octet-stream",
            Metadata={
                "append": "true",
                "append-if-version": ver,
                "append-id": str(uuid.uuid4()),
            },
        )
        return resp["ResponseMetadata"]["HTTPHeaders"].get("x-amz-meta-append-version", str(int(ver) + 1))
    except s3.exceptions.PreconditionFailed as e:  # type: ignore[attr-defined]
        hdrs = e.response.get("ResponseMetadata", {}).get("HTTPHeaders", {})
        next_ver = hdrs.get("x-amz-meta-append-version", ver)
        return next_ver

# Chain appends without HEAD
version = append(b"more-bytes-1", version)
version = append(b"more-bytes-2", version)
```

When to use HEAD

- HEAD is a good choice when you:
  - Only need the current version without writing.
  - Are about to upload a large delta and want to preflight the CAS version to avoid uploading bytes only to receive a 412; reading `x-amz-meta-append-version` via HEAD is cheaper than a failed PUT.
  - Use an SDK that does not expose response headers on success/error; HEAD reliably provides `x-amz-meta-append-version` and may be quicker than additional retries.

Performance

- Each append is O(delta) (publish the new chunk and append to manifest); no rewrite of prior bytes.
- GET remains proportional to total size; Range GETs avoid unnecessary transfer.

Limitations

- Provide CAS (append-if-version) for safe multi-writer operation.
- Idempotency via append-id is supported for retry safety (short-term cache window).
