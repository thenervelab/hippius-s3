"""OVH KMS client for wrapping/unwrapping KEKs using mTLS authentication."""

from __future__ import annotations

import asyncio
import base64
import logging
import random
from typing import TYPE_CHECKING
from typing import Any

import httpx


if TYPE_CHECKING:
    from hippius_s3.config import Config

logger = logging.getLogger(__name__)


class OVHKMSError(Exception):
    """Base exception for OVH KMS errors."""

    pass


class OVHKMSUnavailableError(OVHKMSError):
    """Raised when KMS is unavailable after retries."""

    pass


class OVHKMSAuthenticationError(OVHKMSError):
    """Raised when KMS authentication fails (no retry)."""

    pass


def _compute_backoff_ms(attempt: int, base_ms: int = 500, max_ms: int = 5000) -> float:
    """Compute exponential backoff with jitter."""
    exp_backoff = base_ms * (2 ** (attempt - 1))
    jitter = random.uniform(0, exp_backoff * 0.1)
    return float(min(exp_backoff + jitter, max_ms))


class OVHKMSClient:
    """Client for OVH KMS API with mTLS authentication.

    Provides wrap (encrypt) and unwrap (decrypt) operations for KEK management.
    Uses exponential backoff retry for transient errors.

    Key rotation support:
    - wrap_key() and unwrap_key() accept key_id per call
    - New KEKs should use cfg.ovh_kms_default_key_id
    - Existing KEKs use the key_id stored in their DB row
    - This allows seamless rotation: old keys remain decryptable
    """

    def __init__(self, config: Config | None = None) -> None:
        """Initialize the KMS client with mTLS configuration.

        Args:
            config: Application config. If None, loads via get_config().

        Raises:
            ValueError: If certificate files don't exist.

        Note:
            Use wait_for_certs() before creating the client to handle
            docker-compose race conditions where certs may not be ready yet.
        """
        from pathlib import Path

        if config is None:
            from hippius_s3.config import get_config

            config = get_config()

        self._endpoint = config.ovh_kms_endpoint.rstrip("/")
        self._timeout = config.ovh_kms_timeout_seconds
        self._max_retries = config.ovh_kms_max_retries
        self._retry_base_ms = config.ovh_kms_retry_base_ms
        self._retry_max_ms = config.ovh_kms_retry_max_ms

        # Build mTLS client
        cert_path = config.ovh_kms_cert_path
        key_path = config.ovh_kms_key_path
        ca_path: str | bool = config.ovh_kms_ca_path if config.ovh_kms_ca_path else True

        # Fail fast if certs don't exist (use wait_for_certs() first in async context)
        cert_exists = Path(cert_path).exists()
        key_exists = Path(key_path).exists()
        ca_exists = ca_path is True or (isinstance(ca_path, str) and Path(ca_path).exists())

        if not (cert_exists and key_exists and ca_exists):
            missing = []
            if not cert_exists:
                missing.append(f"cert: {cert_path}")
            if not key_exists:
                missing.append(f"key: {key_path}")
            if isinstance(ca_path, str) and not Path(ca_path).exists():
                missing.append(f"ca: {ca_path}")
            raise ValueError(f"KMS certificate files not found: {', '.join(missing)}")

        self._client = httpx.AsyncClient(
            base_url=self._endpoint,
            cert=(cert_path, key_path),
            verify=ca_path,
            timeout=httpx.Timeout(self._timeout),
        )

    @staticmethod
    async def wait_for_certs(
        config: "Config",
        max_wait_seconds: float = 30.0,
        wait_interval: float = 1.0,
    ) -> None:
        """Wait for KMS certificate files to exist (async-friendly).

        Handles docker-compose race conditions where cert files may be
        generated by another container at startup.

        Args:
            config: Application config with cert paths.
            max_wait_seconds: Maximum time to wait for certs.
            wait_interval: Interval between checks.

        Raises:
            ValueError: If certificate files don't exist after max_wait_seconds.
        """
        import time
        from pathlib import Path

        cert_path = config.ovh_kms_cert_path
        key_path = config.ovh_kms_key_path
        ca_path: str | bool = config.ovh_kms_ca_path if config.ovh_kms_ca_path else True

        start_time = time.monotonic()

        while True:
            cert_exists = Path(cert_path).exists()
            key_exists = Path(key_path).exists()
            ca_exists = ca_path is True or (isinstance(ca_path, str) and Path(ca_path).exists())

            if cert_exists and key_exists and ca_exists:
                return

            elapsed = time.monotonic() - start_time
            if elapsed >= max_wait_seconds:
                missing = []
                if not cert_exists:
                    missing.append(f"cert: {cert_path}")
                if not key_exists:
                    missing.append(f"key: {key_path}")
                if isinstance(ca_path, str) and not Path(ca_path).exists():
                    missing.append(f"ca: {ca_path}")
                raise ValueError(f"KMS certificate files not found after {max_wait_seconds}s: {', '.join(missing)}")

            logger.debug(
                f"Waiting for KMS cert files (elapsed={elapsed:.1f}s): "
                f"cert={cert_exists}, key={key_exists}, ca={ca_exists}"
            )
            await asyncio.sleep(wait_interval)

    async def wrap_key(self, plaintext: bytes, *, key_id: str) -> bytes:
        """Wrap a key using the specified KMS key.

        Uses the dedicated /wrap endpoint (wrapKey operation), which allows
        configuring the KMS key with only wrap/unwrap permissions for tighter security.

        Args:
            plaintext: The plaintext key bytes to wrap.
            key_id: The KMS key ID to use for wrapping (typically the default key).

        Returns:
            The wrapped key bytes.

        Raises:
            OVHKMSAuthenticationError: On authentication failure (401/403).
            OVHKMSUnavailableError: On transient errors after max retries.
            OVHKMSError: On other errors.
        """
        url = f"/v1/servicekey/{key_id}/wrap"
        payload = {"plaintext": base64.b64encode(plaintext).decode("ascii")}

        response = await self._request_with_retry("POST", url, json=payload)

        try:
            data = response.json()
            ciphertext_b64 = data["ciphertext"]
            return base64.b64decode(ciphertext_b64)
        except (KeyError, ValueError) as e:
            raise OVHKMSError(f"Invalid response from KMS wrap: {e}") from e

    async def unwrap_key(self, wrapped: bytes, *, key_id: str) -> bytes:
        """Unwrap a key using the specified KMS key.

        Uses the dedicated /unwrap endpoint (unwrapKey operation), which allows
        configuring the KMS key with only wrap/unwrap permissions for tighter security.

        Args:
            wrapped: The wrapped key bytes.
            key_id: The KMS key ID that was used to wrap (from DB row).

        Returns:
            The plaintext key bytes.

        Raises:
            OVHKMSAuthenticationError: On authentication failure (401/403).
            OVHKMSUnavailableError: On transient errors after max retries.
            OVHKMSError: On other errors.
        """
        url = f"/v1/servicekey/{key_id}/unwrap"
        payload = {"ciphertext": base64.b64encode(wrapped).decode("ascii")}

        response = await self._request_with_retry("POST", url, json=payload)

        try:
            data = response.json()
            plaintext_b64 = data["plaintext"]
            return base64.b64decode(plaintext_b64)
        except (KeyError, ValueError) as e:
            raise OVHKMSError(f"Invalid response from KMS unwrap: {e}") from e

    async def _request_with_retry(self, method: str, url: str, **kwargs: Any) -> httpx.Response:
        """Make an HTTP request with exponential backoff retry.

        Args:
            method: HTTP method (GET, POST, etc.)
            url: Request URL path
            **kwargs: Additional arguments to pass to httpx.request

        Returns:
            The successful HTTP response.

        Raises:
            OVHKMSAuthenticationError: On 401/403 (no retry).
            OVHKMSUnavailableError: After max retries exhausted.
            OVHKMSError: On non-retryable errors.
        """
        last_error: Exception | None = None

        for attempt in range(1, self._max_retries + 1):
            try:
                response = await self._client.request(method, url, **kwargs)

                # Check for auth errors (no retry)
                if response.status_code in (401, 403):
                    raise OVHKMSAuthenticationError(f"KMS authentication failed: {response.status_code}")

                # Check for success (any 2xx)
                if 200 <= response.status_code < 300:
                    return response

                # Check for retryable errors (5xx and 429 rate limit)
                if response.status_code >= 500 or response.status_code == 429:
                    last_error = OVHKMSError(f"KMS returned {response.status_code}: {response.text}")
                    if attempt < self._max_retries:
                        backoff_ms = _compute_backoff_ms(attempt, self._retry_base_ms, self._retry_max_ms)
                        logger.warning(
                            f"KMS request failed (attempt {attempt}/{self._max_retries}), "
                            f"retrying in {backoff_ms:.0f}ms: {response.status_code}"
                        )
                        await asyncio.sleep(backoff_ms / 1000.0)
                        continue
                    # Last attempt - will raise OVHKMSUnavailableError below
                    break

                # Non-retryable client error (4xx except 401/403/429)
                raise OVHKMSError(f"KMS request failed with {response.status_code}: {response.text}")

            except httpx.TimeoutException as e:
                last_error = e
                if attempt < self._max_retries:
                    backoff_ms = _compute_backoff_ms(attempt, self._retry_base_ms, self._retry_max_ms)
                    logger.warning(
                        f"KMS request timeout (attempt {attempt}/{self._max_retries}), retrying in {backoff_ms:.0f}ms"
                    )
                    await asyncio.sleep(backoff_ms / 1000.0)
                    continue

            except httpx.RequestError as e:
                last_error = e
                if attempt < self._max_retries:
                    backoff_ms = _compute_backoff_ms(attempt, self._retry_base_ms, self._retry_max_ms)
                    logger.warning(
                        f"KMS request error (attempt {attempt}/{self._max_retries}), "
                        f"retrying in {backoff_ms:.0f}ms: {e}"
                    )
                    await asyncio.sleep(backoff_ms / 1000.0)
                    continue

        # All retries exhausted
        raise OVHKMSUnavailableError(f"KMS unavailable after {self._max_retries} attempts") from last_error

    async def close(self) -> None:
        """Close the HTTP client and release resources."""
        await self._client.aclose()

    async def __aenter__(self) -> "OVHKMSClient":
        """Context manager entry."""
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: object,
    ) -> None:
        """Context manager exit - close the client."""
        await self.close()
